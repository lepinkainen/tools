<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MediaJoiner</title>
    <link rel="stylesheet" href="../static/common.css" />
    <style>
      /* Tool-specific styles */
      #dropZone.dragover {
        border-color: #00bfff;
        box-shadow: 0 0 30px rgba(0, 191, 255, 0.3);
        background: rgba(0, 191, 255, 0.05);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>
        <svg
          class="tool-icon"
          viewBox="0 0 40 40"
          style="width: 50px; height: 50px"
        >
          <g stroke="#00d9ff" stroke-width="2" fill="none">
            <rect x="2" y="10" width="15" height="20" />
            <rect x="23" y="10" width="15" height="20" />
            <line
              x1="19"
              y1="20"
              x2="21"
              y2="20"
              stroke="#ff1493"
              stroke-width="3"
            />
          </g>
        </svg>
        MediaJoiner
      </h1>
      <p>
        Join two images or videos side-by-side. Upload images/videos separately
        or drag and drop them into the box below.
      </p>

      <div id="dropZone" class="box">
        <p>Drag and drop files here or use the file inputs below</p>
        <p style="font-size: 0.9em; opacity: 0.8">
          Files will be assigned to A and B automatically
        </p>
      </div>

      <div
        style="
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 20px;
          margin: 20px 0;
        "
      >
        <div>
          <label for="fileInputA">File A:</label>
          <input type="file" id="fileInputA" accept="image/*,video/*" />
          <p
            id="fileAStatus"
            style="font-size: 0.9em; margin-top: 5px; min-height: 1.2em"
          >
            No file selected
          </p>
          <div
            style="margin: 8px 0 0; display: flex; gap: 8px; flex-wrap: wrap"
          >
            <button
              type="button"
              id="clearABtn"
              class="secondary"
              onclick="clearSlot(true)"
            >
              Clear A
            </button>
          </div>
          <div
            id="previewA"
            style="
              margin-top: 10px;
              min-height: 120px;
              border: 1px dashed rgba(255, 255, 255, 0.2);
              padding: 8px;
              display: flex;
              align-items: center;
              justify-content: center;
              overflow: hidden;
            "
          ></div>
        </div>
        <div>
          <label for="fileInputB">File B:</label>
          <input type="file" id="fileInputB" accept="image/*,video/*" />
          <p
            id="fileBStatus"
            style="font-size: 0.9em; margin-top: 5px; min-height: 1.2em"
          >
            No file selected
          </p>
          <div
            style="margin: 8px 0 0; display: flex; gap: 8px; flex-wrap: wrap"
          >
            <button
              type="button"
              id="clearBBtn"
              class="secondary"
              onclick="clearSlot(false)"
            >
              Clear B
            </button>
          </div>
          <div
            id="previewB"
            style="
              margin-top: 10px;
              min-height: 120px;
              border: 1px dashed rgba(255, 255, 255, 0.2);
              padding: 8px;
              display: flex;
              align-items: center;
              justify-content: center;
              overflow: hidden;
            "
          ></div>
        </div>
      </div>

      <div
        style="
          display: flex;
          justify-content: center;
          gap: 12px;
          margin-bottom: 20px;
        "
      >
        <button
          type="button"
          id="swapBtn"
          class="secondary"
          onclick="swapMedia()"
        >
          Swap A ↔ B
        </button>
      </div>

      <div
        id="error"
        style="
          display: none;
          color: #ff0000;
          background: rgba(255, 0, 0, 0.1);
          padding: 12px;
          border-radius: 5px;
          margin: 10px 0;
        "
      ></div>

      <button id="generateBtn" onclick="generate()">Generate</button>

      <div id="output" class="output"></div>
    </div>

    <script>
      let mediaA = null,
        mediaB = null;
      let mediaAUrl = null,
        mediaBUrl = null;
      let fileA = null,
        fileB = null; // Store original File objects for hashing
      let outputUrl = null; // Store the generated blob URL
      let outputBlob = null; // Store the generated blob for reuse
      let outputFilename = null; // Store the filename

      // Error handling functions
      function showError(message) {
        const errorDiv = document.getElementById("error");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
      }

      function hideError() {
        const errorDiv = document.getElementById("error");
        errorDiv.style.display = "none";
      }

      // Update file status indicators
      function updateStatus(isA, text, color = "") {
        const statusEl = document.getElementById(
          isA ? "fileAStatus" : "fileBStatus"
        );
        statusEl.textContent = text;
        statusEl.style.color = color;
      }

      function renderPreview(isA, media) {
        const container = document.getElementById(
          isA ? "previewA" : "previewB"
        );
        container.innerHTML = "";

        if (!media) {
          const placeholder = document.createElement("p");
          placeholder.textContent = "No preview";
          placeholder.style.opacity = "0.6";
          placeholder.style.fontSize = "0.85em";
          container.appendChild(placeholder);
          return;
        }

        const preview = media.cloneNode(false);
        preview.src = media.src;
        preview.style.maxWidth = "100%";
        preview.style.maxHeight = "200px";
        preview.style.objectFit = "contain";
        preview.style.borderRadius = "6px";
        preview.setAttribute("aria-label", isA ? "Preview A" : "Preview B");
        preview.draggable = false;

        if (preview.tagName === "VIDEO") {
          preview.controls = true;
          preview.muted = true;
          preview.loop = true;
          preview.playsInline = true;
          preview.autoplay = true;
        }

        container.appendChild(preview);
      }

      function releaseMedia(isA) {
        const media = isA ? mediaA : mediaB;
        const url = isA ? mediaAUrl : mediaBUrl;

        if (media) {
          if (media.tagName === "VIDEO") {
            try {
              media.pause();
            } catch (e) {
              // Ignore pause failures
            }
            media.removeAttribute("src");
            media.load();
          } else if (media.tagName === "IMG") {
            media.src = "";
          }
        }

        if (url) {
          URL.revokeObjectURL(url);
        }

        if (isA) {
          mediaA = null;
          mediaAUrl = null;
          fileA = null;
        } else {
          mediaB = null;
          mediaBUrl = null;
          fileB = null;
        }

        renderPreview(isA, null);
      }

      function clearSlot(isA) {
        releaseMedia(isA);
        const input = document.getElementById(
          isA ? "fileInputA" : "fileInputB"
        );
        input.value = "";
        updateStatus(isA, "No file selected");
      }

      function swapMedia() {
        if (!mediaA && !mediaB) {
          return;
        }

        [mediaA, mediaB] = [mediaB, mediaA];
        [mediaAUrl, mediaBUrl] = [mediaBUrl, mediaAUrl];
        [fileA, fileB] = [fileB, fileA];

        const statusA = fileA ? `✓ ${fileA.name}` : "No file selected";
        const statusB = fileB ? `✓ ${fileB.name}` : "No file selected";
        updateStatus(true, statusA, fileA ? "#00ff41" : "");
        updateStatus(false, statusB, fileB ? "#00ff41" : "");

        renderPreview(true, mediaA);
        renderPreview(false, mediaB);
      }

      function resetOutput() {
        if (outputUrl && outputUrl.startsWith("blob:")) {
          URL.revokeObjectURL(outputUrl);
        }
        outputUrl = null;
        outputBlob = null;
        outputFilename = null;
        const output = document.getElementById("output");
        output.innerHTML = "";
      }

      function setProgress(message) {
        const output = document.getElementById("output");
        output.innerHTML = `<p id="progressText">${message}</p>`;
      }

      function updateProgress(message) {
        const progress = document.getElementById("progressText");
        if (progress) {
          progress.textContent = message;
        }
      }

      // Drag-and-drop setup
      const dropZone = document.getElementById("dropZone");
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("dragover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("dragover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("dragover");
        const files = Array.from(e.dataTransfer.files);
        handleDroppedFiles(files);
      });

      // Handle dropped files - assign to A or B automatically
      function handleDroppedFiles(files) {
        if (files.length === 0) return;

        hideError();

        // Assign first file to A if empty, otherwise to B
        if (!mediaA && files[0]) {
          assignFile(files[0], true);
        }

        // Assign second file to B if available
        if (files[1]) {
          assignFile(files[1], false);
        } else if (!mediaB && files[0] && mediaA) {
          // If only one file dropped and A is already filled, assign to B
          assignFile(files[0], false);
        }
      }

      // File input handlers
      document.getElementById("fileInputA").addEventListener("change", (e) => {
        if (e.target.files[0]) {
          assignFile(e.target.files[0], true);
        }
      });

      document.getElementById("fileInputB").addEventListener("change", (e) => {
        if (e.target.files[0]) {
          assignFile(e.target.files[0], false);
        }
      });

      renderPreview(true, null);
      renderPreview(false, null);

      function assignFile(file, isA) {
        if (
          !file.type.startsWith("image/") &&
          !file.type.startsWith("video/")
        ) {
          showError("Please select an image or video file");
          return;
        }

        const previousFile = isA ? fileA : fileB;
        const hadPrevious = Boolean(previousFile);

        hideError();
        updateStatus(isA, "Loading...");
        const isVideo = file.type.startsWith("video/");
        const media = isVideo
          ? document.createElement("video")
          : document.createElement("img");
        const objectUrl = URL.createObjectURL(file);
        media.preload = "auto";
        media.src = objectUrl;
        const loadHandler = isVideo ? "onloadedmetadata" : "onload";

        media[loadHandler] = () => {
          if (isVideo) {
            const width = media.videoWidth || media.naturalWidth || 0;
            const height = media.videoHeight || media.naturalHeight || 0;
            if (width <= 0 || height <= 0) {
              URL.revokeObjectURL(objectUrl);
              showError(`Failed to load dimensions for ${file.name}`);
              updateStatus(isA, "No file selected");
              return;
            }
          }

          releaseMedia(isA);

          if (isA) {
            mediaA = media;
            mediaAUrl = objectUrl;
            fileA = file;
            updateStatus(true, `✓ ${file.name}`, "#00ff41");
            renderPreview(true, mediaA);
            document.getElementById("fileInputA").value = "";
          } else {
            mediaB = media;
            mediaBUrl = objectUrl;
            fileB = file;
            updateStatus(false, `✓ ${file.name}`, "#00ff41");
            renderPreview(false, mediaB);
            document.getElementById("fileInputB").value = "";
          }
        };

        media.onerror = () => {
          URL.revokeObjectURL(objectUrl);
          showError(`Failed to load ${file.name}`);
          if (hadPrevious && previousFile) {
            updateStatus(isA, `✓ ${previousFile.name}`, "#00ff41");
          } else {
            updateStatus(isA, "No file selected");
            renderPreview(isA, null);
          }
        };
      }

      function getDimensions(media) {
        if (media.tagName === "VIDEO") {
          return [
            media.videoWidth || media.naturalWidth || 0,
            media.videoHeight || media.naturalHeight || 0,
          ];
        } else {
          return [media.naturalWidth, media.naturalHeight];
        }
      }

      // Hash a file using SHA-256 (first 8 hex chars for brevity)
      async function hashFile(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("")
          .slice(0, 8);
      }

      async function generate() {
        if (!mediaA || !mediaB || !fileA || !fileB) {
          showError("Please load both File A and File B first");
          return;
        }

        hideError();
        resetOutput();
        setProgress("Hashing files...");

        const generateBtn = document.getElementById("generateBtn");
        generateBtn.disabled = true;
        generateBtn.textContent = "Generating...";

        // Disable slot controls during generation to prevent race condition
        const clearABtn = document.getElementById("clearABtn");
        const clearBBtn = document.getElementById("clearBBtn");
        const swapBtn = document.getElementById("swapBtn");
        clearABtn.disabled = true;
        clearBBtn.disabled = true;
        swapBtn.disabled = true;

        try {
          const [hashA, hashB] = await Promise.all([
            hashFile(fileA),
            hashFile(fileB),
          ]);
          const combinedHash = `${hashA}-${hashB}`;
          const isVideoOut =
            mediaA.tagName === "VIDEO" || mediaB.tagName === "VIDEO";
          const ext = isVideoOut ? ".webm" : ".png";
          outputFilename = `mjgen-${combinedHash}${ext}`;

          const [w1, h1] = getDimensions(mediaA);
          const [w2, h2] = getDimensions(mediaB);
          if (w1 === 0 || w2 === 0) {
            throw new Error(
              "Invalid media dimensions - could not read file dimensions"
            );
          }

          const output = document.getElementById("output");

          if (!isVideoOut) {
            setProgress("Combining images...");
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              throw new Error("Failed to get 2D drawing context");
            }
            const maxH = Math.max(h1, h2);
            canvas.width = w1 + w2;
            canvas.height = maxH;
            ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
            ctx.drawImage(mediaB, w1, (maxH - h2) / 2);

            const blob = await new Promise((resolve) =>
              canvas.toBlob((b) => resolve(b), "image/png")
            );

            if (!blob) {
              throw new Error("Failed to encode image");
            }

            outputBlob = blob;
            outputUrl = URL.createObjectURL(blob);
            const sizeLabel = (blob.size / (1024 * 1024)).toFixed(2);
            output.innerHTML = `
                    <img src="${outputUrl}" alt="Joined media output showing two images side by side" style="max-width: 100%; border-radius: 6px;">
                    <p style="font-size: 0.85em; opacity: 0.8;">Estimated size: ${sizeLabel} MB</p>
                    <button id="downloadBtn" class="secondary" onclick="downloadOutput()">Download ${outputFilename}</button>
                `;
          } else {
            setProgress("Preparing video renderer...");
            let duration = Infinity;
            if (mediaA.tagName === "VIDEO")
              duration = Math.min(duration, mediaA.duration);
            if (mediaB.tagName === "VIDEO")
              duration = Math.min(duration, mediaB.duration);
            if (!isFinite(duration) || isNaN(duration) || duration <= 0) {
              throw new Error(
                "Invalid video duration - video may not be loaded properly"
              );
            }

            const canvas = document.createElement("canvas");
            if (typeof canvas.captureStream !== "function") {
              throw new Error(
                "Browser does not support canvas captureStream required for video output"
              );
            }
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              throw new Error("Failed to get 2D drawing context");
            }
            const maxH = Math.max(h1, h2);
            canvas.width = w1 + w2;
            canvas.height = maxH;

            if (typeof MediaRecorder === "undefined") {
              throw new Error("MediaRecorder is not supported in this browser");
            }

            const preferredTypes = [
              "video/webm;codecs=vp9",
              "video/webm;codecs=vp8",
              "video/webm",
            ];
            const mimeType = preferredTypes.find((type) =>
              MediaRecorder.isTypeSupported
                ? MediaRecorder.isTypeSupported(type)
                : true
            );

            if (!mimeType) {
              throw new Error("No supported MediaRecorder MIME type found");
            }

            await new Promise((resolve, reject) => {
              let recorder;
              const chunks = [];
              let settled = false;

              const finishError = (err) => {
                if (settled) return;
                settled = true;
                try {
                  if (recorder && recorder.state !== "inactive") {
                    recorder.stop();
                  }
                } catch (e) {
                  // ignore stop errors
                }
                reject(err);
              };

              const finishSuccess = () => {
                if (settled) return;
                settled = true;
                resolve();
              };

              try {
                const stream = canvas.captureStream(30);
                recorder = new MediaRecorder(stream, { mimeType });
              } catch (err) {
                finishError(err);
                return;
              }

              recorder.ondataavailable = (e) => {
                if (e.data && e.data.size > 0) {
                  chunks.push(e.data);
                }
              };

              recorder.onerror = (event) => {
                finishError(
                  new Error(
                    event.error?.message || event.error || "Recording error"
                  )
                );
              };

              recorder.onstop = () => {
                if (settled) {
                  return;
                }
                if (!chunks.length) {
                  finishError(new Error("Failed to record video output"));
                  return;
                }
                const blob = new Blob(chunks, { type: mimeType });
                outputBlob = blob;
                outputUrl = URL.createObjectURL(blob);
                const sizeLabel = (blob.size / (1024 * 1024)).toFixed(2);
                output.innerHTML = "";
                const videoElement = document.createElement("video");
                videoElement.src = outputUrl;
                videoElement.controls = true;
                videoElement.autoplay = true;
                videoElement.loop = true;
                videoElement.style.maxWidth = "100%";
                videoElement.style.borderRadius = "6px";
                output.appendChild(videoElement);
                const meta = document.createElement("p");
                meta.style.fontSize = "0.85em";
                meta.style.opacity = "0.8";
                meta.textContent = `Estimated size: ${sizeLabel} MB`;
                output.appendChild(meta);
                const downloadBtn = document.createElement("button");
                downloadBtn.id = "downloadBtn";
                downloadBtn.className = "secondary";
                downloadBtn.textContent = `Download ${outputFilename}`;
                downloadBtn.onclick = downloadOutput;
                output.appendChild(downloadBtn);
                finishSuccess();
              };

              if (mediaA.tagName === "VIDEO") {
                mediaA.pause();
                mediaA.currentTime = 0;
              }
              if (mediaB.tagName === "VIDEO") {
                mediaB.pause();
                mediaB.currentTime = 0;
              }

              const totalDuration = duration;
              let startTime = null;
              setProgress(
                `Encoding video: 0.00 / ${totalDuration.toFixed(2)}s`
              );

              function drawFrame(timestamp) {
                if (settled) {
                  return;
                }
                if (!startTime) startTime = timestamp;
                const elapsed = (timestamp - startTime) / 1000;
                const clampedElapsed = Math.min(elapsed, totalDuration);

                updateProgress(
                  `Encoding video: ${clampedElapsed.toFixed(
                    2
                  )} / ${totalDuration.toFixed(2)}s`
                );

                const t = clampedElapsed;
                if (mediaA.tagName === "VIDEO") mediaA.currentTime = t;
                if (mediaB.tagName === "VIDEO") mediaB.currentTime = t;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
                ctx.drawImage(mediaB, w1, (maxH - h2) / 2);

                if (clampedElapsed >= totalDuration) {
                  recorder.stop();
                  return;
                }

                requestAnimationFrame(drawFrame);
              }

              recorder.start();
              requestAnimationFrame(drawFrame);
            });
          }
        } catch (error) {
          console.error("Generation error:", error);
          showError(`Error generating output: ${error.message}`);
          resetOutput();
        } finally {
          generateBtn.disabled = false;
          generateBtn.textContent = "Generate";

          // Re-enable slot controls after generation completes
          clearABtn.disabled = false;
          clearBBtn.disabled = false;
          swapBtn.disabled = false;
        }
      }

      function downloadOutput() {
        if ((!outputUrl && !outputBlob) || !outputFilename) {
          showError("No output to download - please generate output first");
          return;
        }
        downloadBlob(outputFilename);
      }

      function downloadBlob(filename) {
        let urlForDownload = outputUrl;
        if (
          outputBlob &&
          (!urlForDownload || !urlForDownload.startsWith("blob:"))
        ) {
          urlForDownload = URL.createObjectURL(outputBlob);
        }

        if (!urlForDownload) {
          showError("Download unavailable - please regenerate output");
          return;
        }

        const a = document.createElement("a");
        a.href = urlForDownload;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        if (outputBlob && urlForDownload !== outputUrl) {
          setTimeout(() => URL.revokeObjectURL(urlForDownload), 1000);
        }
      }
    </script>

    <!-- Load graphics utilities -->
    <script src="../static/graphics.js"></script>
    <script>
      // Initialize graphics on load
      document.addEventListener("DOMContentLoaded", () => {
        initGraphics({
          circuits: true, // Add circuit corners to boxes
          scanLines: false, // Subtle scan lines
          dataStream: false, // Floating data particles
          promptIcons: false, // Chevron icons on headings
        });
      });

      // Override default loading behavior to use custom spinner
      const originalGenerate = generate;
      generate = function () {
        showLoading("Processing media...");
        originalGenerate().finally(() => {
          hideLoading();
        });
      };
    </script>
  </body>
</html>
