<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MediaJoiner</title>
    <link rel="stylesheet" href="../common.css" />
    <style>
      /* Tool-specific styles */
      #dropZone.dragover {
        border-color: #00bfff;
        box-shadow: 0 0 30px rgba(0, 191, 255, 0.3);
        background: rgba(0, 191, 255, 0.05);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>MediaJoiner</h1>
      <p>Join two images or videos side-by-side. Upload images/videos separately or drag and drop them into the box below.</p>

      <div id="dropZone" class="box">
        <p>Drag and drop files here or use the file inputs below</p>
        <p style="font-size: 0.9em; opacity: 0.8;">Files will be assigned to A and B automatically</p>
      </div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
        <div>
          <label for="fileInputA">File A:</label>
          <input type="file" id="fileInputA" accept="image/*,video/*" />
          <p id="fileAStatus" style="font-size: 0.9em; margin-top: 5px; min-height: 1.2em;"></p>
        </div>
        <div>
          <label for="fileInputB">File B:</label>
          <input type="file" id="fileInputB" accept="image/*,video/*" />
          <p id="fileBStatus" style="font-size: 0.9em; margin-top: 5px; min-height: 1.2em;"></p>
        </div>
      </div>

      <div id="error" style="display: none; color: #ff0000; background: rgba(255, 0, 0, 0.1); padding: 12px; border-radius: 5px; margin: 10px 0;"></div>

      <button onclick="generate()">Generate</button>

      <div id="output" class="output"></div>
    </div>

    <script>
      let mediaA = null,
        mediaB = null;
      let fileA = null,
        fileB = null; // Store original File objects for hashing
      let outputUrl = null; // Store the generated blob URL
      let outputFilename = null; // Store the filename

      // Error handling functions
      function showError(message) {
        const errorDiv = document.getElementById("error");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
      }

      function hideError() {
        const errorDiv = document.getElementById("error");
        errorDiv.style.display = "none";
      }

      // Update file status indicators
      function updateStatus(isA, filename) {
        const statusEl = document.getElementById(isA ? "fileAStatus" : "fileBStatus");
        statusEl.textContent = `âœ“ ${filename}`;
        statusEl.style.color = "#00ff41";
      }

      // Drag-and-drop setup
      const dropZone = document.getElementById("dropZone");
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("dragover");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("dragover");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("dragover");
        const files = Array.from(e.dataTransfer.files);
        handleDroppedFiles(files);
      });

      // Handle dropped files - assign to A or B automatically
      function handleDroppedFiles(files) {
        if (files.length === 0) return;

        hideError();

        // Assign first file to A if empty, otherwise to B
        if (!mediaA && files[0]) {
          assignFile(files[0], true);
        }

        // Assign second file to B if available
        if (files[1]) {
          assignFile(files[1], false);
        } else if (!mediaB && files[0] && mediaA) {
          // If only one file dropped and A is already filled, assign to B
          assignFile(files[0], false);
        }
      }

      // File input handlers
      document.getElementById("fileInputA").addEventListener("change", (e) => {
        if (e.target.files[0]) {
          assignFile(e.target.files[0], true);
        }
      });

      document.getElementById("fileInputB").addEventListener("change", (e) => {
        if (e.target.files[0]) {
          assignFile(e.target.files[0], false);
        }
      });

      function assignFile(file, isA) {
        if (!file.type.startsWith("image/") && !file.type.startsWith("video/")) {
          showError("Please select an image or video file");
          return;
        }

        hideError();
        const isVideo = file.type.startsWith("video/");
        const media = isVideo
          ? document.createElement("video")
          : document.createElement("img");
        media.src = URL.createObjectURL(file);
        const loadHandler = isVideo ? "onloadedmetadata" : "onload";

        media[loadHandler] = () => {
          if (isA) {
            mediaA = media;
            fileA = file;
            updateStatus(true, file.name);
          } else {
            mediaB = media;
            fileB = file;
            updateStatus(false, file.name);
          }
          console.log(`${isA ? "A" : "B"} loaded:`, media);
        };

        media.onerror = () => {
          showError(`Failed to load ${file.name}`);
        };
      }

      function getDimensions(media) {
        if (media.tagName === "VIDEO") {
          return [
            media.videoWidth || media.naturalWidth || 0,
            media.videoHeight || media.naturalHeight || 0,
          ];
        } else {
          return [media.naturalWidth, media.naturalHeight];
        }
      }

      // Hash a file using SHA-256 (first 8 hex chars for brevity)
      async function hashFile(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("")
          .slice(0, 8);
      }

      async function generate() {
        if (!mediaA || !mediaB || !fileA || !fileB) {
          showError("Please load both File A and File B first");
          return;
        }

        hideError();
        const output = document.getElementById("output");
        output.innerHTML = "<p>Generating...</p>";

        try {
          // Compute unique hash from both files
          const [hashA, hashB] = await Promise.all([
            hashFile(fileA),
            hashFile(fileB),
          ]);
          const combinedHash = `${hashA}-${hashB}`;
          const isVideoOut =
            mediaA.tagName === "VIDEO" || mediaB.tagName === "VIDEO";
          const ext = isVideoOut ? ".webm" : ".png";
          outputFilename = `mjgen-${combinedHash}${ext}`; // Updated prefix to mjgen for MediaJoiner

          const [w1, h1] = getDimensions(mediaA);
          const [w2, h2] = getDimensions(mediaB);
          if (w1 === 0 || w2 === 0) {
            showError("Invalid media dimensions - could not read file dimensions");
            output.innerHTML = "";
            return;
          }

        if (!isVideoOut) {
          // Static image output
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const maxH = Math.max(h1, h2);
          canvas.width = w1 + w2;
          canvas.height = maxH;
          ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
          ctx.drawImage(mediaB, w1, (maxH - h2) / 2);
          outputUrl = canvas.toDataURL("image/png");
          output.innerHTML = `
                    <img src="${outputUrl}" alt="Result">
                    <br><button id="downloadBtn" class="secondary" onclick="downloadOutput()">Download ${outputFilename}</button>
                `;
        } else {
          // Video output: Composite and record
          let duration = Infinity;
          if (mediaA.tagName === "VIDEO")
            duration = Math.min(duration, mediaA.duration);
          if (mediaB.tagName === "VIDEO")
            duration = Math.min(duration, mediaB.duration);
          if (isNaN(duration) || duration <= 0) {
            showError("Invalid video duration - video may not be loaded properly");
            output.innerHTML = "";
            return;
          }

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const maxH = Math.max(h1, h2);
          canvas.width = w1 + w2;
          canvas.height = maxH;

          // Get stream from canvas for recording
          const stream = canvas.captureStream(30); // 30 FPS
          const recorder = new MediaRecorder(stream, {
            mimeType: "video/webm;codecs=vp9",
          });
          const chunks = [];

          recorder.ondataavailable = (e) => chunks.push(e.data);
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: "video/webm" });
            outputUrl = URL.createObjectURL(blob);
            output.innerHTML = `
                        <video src="${outputUrl}" controls autoplay></video>
                        <br><button id="downloadBtn" class="secondary" onclick="downloadOutput()">Download ${outputFilename}</button>
                    `;
          };

          // Play only video elements
          if (mediaA.tagName === "VIDEO") mediaA.play();
          if (mediaB.tagName === "VIDEO") mediaB.play();

          // Sync draw frames
          let startTime = null;
          function drawFrame(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = (timestamp - startTime) / 1000;
            if (elapsed > duration) {
              recorder.stop();
              // Pause videos to clean up
              if (mediaA.tagName === "VIDEO") mediaA.pause();
              if (mediaB.tagName === "VIDEO") mediaB.pause();
              return;
            }

            const t = elapsed;
            // Set time only for videos
            if (mediaA.tagName === "VIDEO") mediaA.currentTime = t;
            if (mediaB.tagName === "VIDEO") mediaB.currentTime = t;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
            ctx.drawImage(mediaB, w1, (maxH - h2) / 2);
            requestAnimationFrame(drawFrame);
          }

          recorder.start();
          requestAnimationFrame(drawFrame);
        }
        } catch (error) {
          showError(`Error generating output: ${error.message}`);
          output.innerHTML = "";
          console.error("Generation error:", error);
        }
      }

      function downloadOutput() {
        if (!outputUrl || !outputFilename) {
          showError("No output to download - please generate output first");
          return;
        }
        downloadBlob(outputUrl, outputFilename);
      }

      function downloadBlob(url, filename) {
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
      }
    </script>
  </body>
</html>
