<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MediaJoiner</title>
    <link rel="stylesheet" href="../common.css" />
    <style>
      /* Tool-specific styles */
      #dropZone.dragover {
        border-color: #00bfff;
        box-shadow: 0 0 30px rgba(0, 191, 255, 0.3);
        background: rgba(0, 191, 255, 0.05);
      }
    </style>
  </head>
  <body>
    <h1>MediaJoiner</h1>
    <div id="dropZone" class="box">Drag A and B here (images/videos)</div>
    <input type="file" id="fileInputA" accept="image/*,video/*" multiple />
    <input type="file" id="fileInputB" accept="image/*,video/*" multiple />
    <br />
    <button onclick="generate()">Generate</button>
    <div id="output" class="output"></div>

    <script>
      let mediaA = null,
        mediaB = null;
      let fileA = null,
        fileB = null; // Store original File objects for hashing
      let outputUrl = null; // Store the generated blob URL
      let outputFilename = null; // Store the filename

      // Drag-and-drop setup (simplified)
      const dropZone = document.getElementById("dropZone");
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("dragover");
      });
      dropZone.addEventListener("dragleave", () =>
        dropZone.classList.remove("dragover")
      );
      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("dragover");
        const files = Array.from(e.dataTransfer.files);
        assignFiles(files);
      });
      document
        .getElementById("fileInputA")
        .addEventListener("change", (e) => assignFiles(e.target.files, true));
      document
        .getElementById("fileInputB")
        .addEventListener("change", (e) => assignFiles(e.target.files, false));

      function assignFiles(files, isA = null) {
        if (files.length !== 1) return alert("One file per input");
        const file = files[0];
        const isVideo = file.type.startsWith("video/");
        const media = isVideo
          ? document.createElement("video")
          : document.createElement("img");
        media.src = URL.createObjectURL(file);
        const loadHandler = isVideo ? "onloadedmetadata" : "onload";
        media[loadHandler] = () => {
          // Wait for load/metadata
          if (isA) {
            mediaA = media;
            fileA = file;
          } else {
            mediaB = media;
            fileB = file;
          }
          console.log(`${isA ? "A" : "B"} loaded:`, media);
        };
      }

      function getDimensions(media) {
        if (media.tagName === "VIDEO") {
          return [
            media.videoWidth || media.naturalWidth || 0,
            media.videoHeight || media.naturalHeight || 0,
          ];
        } else {
          return [media.naturalWidth, media.naturalHeight];
        }
      }

      // Hash a file using SHA-256 (first 8 hex chars for brevity)
      async function hashFile(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("")
          .slice(0, 8);
      }

      async function generate() {
        if (!mediaA || !mediaB || !fileA || !fileB)
          return alert("Load A and B first");

        const output = document.getElementById("output");
        output.innerHTML = "<p>Generating...</p>";

        // Compute unique hash from both files
        const [hashA, hashB] = await Promise.all([
          hashFile(fileA),
          hashFile(fileB),
        ]);
        const combinedHash = `${hashA}-${hashB}`;
        const isVideoOut =
          mediaA.tagName === "VIDEO" || mediaB.tagName === "VIDEO";
        const ext = isVideoOut ? ".webm" : ".png";
        outputFilename = `mjgen-${combinedHash}${ext}`; // Updated prefix to mjgen for MediaJoiner

        const [w1, h1] = getDimensions(mediaA);
        const [w2, h2] = getDimensions(mediaB);
        if (w1 === 0 || w2 === 0) return alert("Invalid media dimensions");

        if (!isVideoOut) {
          // Static image output
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const maxH = Math.max(h1, h2);
          canvas.width = w1 + w2;
          canvas.height = maxH;
          ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
          ctx.drawImage(mediaB, w1, (maxH - h2) / 2);
          outputUrl = canvas.toDataURL("image/png");
          output.innerHTML = `
                    <img src="${outputUrl}" alt="Result">
                    <br><button id="downloadBtn" class="secondary" onclick="downloadOutput()">Download ${outputFilename}</button>
                `;
        } else {
          // Video output: Composite and record
          let duration = Infinity;
          if (mediaA.tagName === "VIDEO")
            duration = Math.min(duration, mediaA.duration);
          if (mediaB.tagName === "VIDEO")
            duration = Math.min(duration, mediaB.duration);
          if (isNaN(duration) || duration <= 0)
            return alert("Invalid video duration");

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const maxH = Math.max(h1, h2);
          canvas.width = w1 + w2;
          canvas.height = maxH;

          // Get stream from canvas for recording
          const stream = canvas.captureStream(30); // 30 FPS
          const recorder = new MediaRecorder(stream, {
            mimeType: "video/webm;codecs=vp9",
          });
          const chunks = [];

          recorder.ondataavailable = (e) => chunks.push(e.data);
          recorder.onstop = () => {
            const blob = new Blob(chunks, { type: "video/webm" });
            outputUrl = URL.createObjectURL(blob);
            output.innerHTML = `
                        <video src="${outputUrl}" controls autoplay></video>
                        <br><button id="downloadBtn" class="secondary" onclick="downloadOutput()">Download ${outputFilename}</button>
                    `;
          };

          // Play only video elements
          if (mediaA.tagName === "VIDEO") mediaA.play();
          if (mediaB.tagName === "VIDEO") mediaB.play();

          // Sync draw frames
          let startTime = null;
          function drawFrame(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = (timestamp - startTime) / 1000;
            if (elapsed > duration) {
              recorder.stop();
              // Pause videos to clean up
              if (mediaA.tagName === "VIDEO") mediaA.pause();
              if (mediaB.tagName === "VIDEO") mediaB.pause();
              return;
            }

            const t = elapsed;
            // Set time only for videos
            if (mediaA.tagName === "VIDEO") mediaA.currentTime = t;
            if (mediaB.tagName === "VIDEO") mediaB.currentTime = t;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mediaA, 0, (maxH - h1) / 2);
            ctx.drawImage(mediaB, w1, (maxH - h2) / 2);
            requestAnimationFrame(drawFrame);
          }

          recorder.start();
          requestAnimationFrame(drawFrame);
        }
      }

      function downloadOutput() {
        if (!outputUrl || !outputFilename)
          return alert("No output to download");
        downloadBlob(outputUrl, outputFilename);
      }

      function downloadBlob(url, filename) {
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
      }
    </script>
  </body>
</html>
